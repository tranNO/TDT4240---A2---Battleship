%!TEX root = main.tex
\chapter{Relationship with the architecture}
\label{cha:relationship_with_the_architecture}
% This section should list the inconsistencies between your architecture and the implementation. Give the reasons for these inconsistencies. Discuss whether they could have been discovered at an earlier point, for instance during the ATAM evaluation.

This chapter lists the inconsistencies between our architecture as described in chapter \ref{cha:design_details} and the actual implementation, followed by a discussion on whether or not these inconsistencies could have been discovered at an earlier point in time.



\section{Patterns}

\subsection{Model-View-Controller}
\label{sec:mvc}

We did have some initial problems with naming conventions, but as soon as these where fixed, the code base has been a joy to work with.
Our implementation is functional, but not complete. The possibility to use 'PropertyChangeSupportListeners' have not utilized, even tho support for this has been included in the implementation of Abstract factory pattern (\ref{sec:absfac}).

But other than that the implementation consists of a controller which contains one model and one view, where the view draws the model based on the variables contained in the model-object. Every change done to the model have to come through the controller-object.


\subsection{Observer pattern}

An implementation that followed the convensions completely

This would mean that the warships' controllers would have received a notification that their state has changed.

Our implementation does not implement such information flow between the objects, but rather checks their status themselves for updates whenever they are being drawn to the screen.
A proper way would have the warships register as listeners for state changes. When a state change occurs, the 

\texttt{OceanSpaceController} distribute this state change to every observer

We did try to implement the pattern as planned in the beginning, but as the code base grew, this proved difficult to properly realise.

The pattern works best in instances where an object has several observers. This was thus thought to applicable to our 
, but in the end seemed to involve more overhead than it was worth. We discovered that in most cases, this message would have been broadcasted to only one observer (e.g. only one warship can occupy any ocean tile at any time).

Time constraints was also a factor in our unability to implement it. With more time, a proper way of implementing it could have been discovered and properly realised.

Whether or not this could have been discovered earlier is hard to say. There were some conserns that we had decided upon too many patterns, and that this could potentially introduce unwanted and unnecessary overhead. For such a simple game as LaHAW this could be more trouble than it was worth.



\subsection{Abstract factory}
\label{sec:absfac}
The abstract factory pattern's purpose in LaHAW is to support the Model-View-Controller (\ref{sec:mvc}). This is implemented so that the required methods and variables required er implemented in the Abstract class. For instance the 'AbstractController' class contains the methods required by the Model-View-Controller pattern and is this example.




\subsection{Singleton}
Our use of the singleton pattern has been limited, as intended.

Singleton was initailly implemented to variables required by the game, but was unreachable localy by the game-states.
For instance the canvas with is not set for the first initial two draws for some weird reason, so these variables where stored in the 'StaticVariables' class which was implemented as a singleton. This would ensure that these variables where not changed durring runtime and we where able to culculate the correct size of the grid-tiles and then draw it correctly.


\section{Quality requirements}

\section{Modifiability}
To furfill this requirement we need to implement someway for the user to change how selected components are displayed.

To ensure that this requirement was met, we implemented so that the user could change both the players name and the color for each player. Inittialy it was planed that the ships color was to be in the same colors as the players color, but when it was discovered how much work required to implement this feature, it was scrapped and redesigned so that only the players name was written in the selected color.

In addition to this the user has the possibility to select the size of his 'OceanSpace', this will increas or decrease the difficulty of hitting your enemy. An unintentional side-effect of this is that the enemy also find it easier to hit your ships.


\section{Usability}
TODO: Skrive at ikke har tekt vanvittig mye på det, men har lagt opp til å implementere det, etc. Smøre godt på.




\section{Experience} % Todo: ny tittel
Our main piece of experience from the implementation phase of this project was that we tried to implement too many patterns. While we still feel that every pattern decided upon in some way or another did fit our project, and.... 

, we feel that implementing fewer patterns better would have benefited the project.

We are however content with our implementation of the model view controller pattern.







